package main

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var (
	export = flag.Bool("export", false,
		"Set to true to export a getter function")
	pkg = flag.String("package", "",
		"Name of the package in the output file")
	outFile = flag.String("output", "spvbin.go",
		"Name of the output file")
	clearFunc = flag.Bool("clear-func", false,
		"Include a function to clears the modules from memory")
)

const (
	genComment = "// Code generated by github.com/jclc/spvbin. DO NOT EDIT."
)

func main() {
	flag.Parse()

	if *pkg == "" {
		fmt.Println("No package name given")
		os.Exit(1)
	}

	files := flag.Args()
	var dirs []int // indices of dirs to remove from 'files'

	for i, f := range files {
		info, err := os.Stat(f)
		if os.IsNotExist(err) {
			fmt.Println("File", f, "does not exist")
			os.Exit(1)
		}
		if info.IsDir() {
			// If a directory is supplied as an argument, add all .spv files in that directory.
			dirs = append(dirs, i)
			d, err := ioutil.ReadDir(f)
			if err != nil {
				panic(err)
			}

			for i := range d {
				if !d[i].IsDir() && strings.HasSuffix(d[i].Name(), ".spv") {
					files = append(files, filepath.Join(f, d[i].Name()))
				}
			}
		} else {
			if !strings.HasSuffix(f, ".spv") {
				fmt.Println("File", f, "is not an .spv file")
				os.Exit(1)
			}
		}
	}

	// Remove any directories in 'files'
	if dirs != nil {
		tmp := files
		files = make([]string, 0, len(tmp)-len(dirs))
		diri := 0
		for i := range tmp {
			if diri < len(dirs) && dirs[diri] == i {
				diri++
			} else {
				files = append(files, tmp[i])
			}
		}
	}

	if len(files) == 0 {
		fmt.Println("No input files.")
		os.Exit(1)
	}

	sort.Strings(files)

	r := strings.NewReplacer(
		".", "_",
		"-", "_",
		" ", "_",
	)
	var constPrefix string
	if *export {
		constPrefix = "SPV_"
	} else {
		constPrefix = "spv_"
	}
	constNames := make(map[string]string, len(files))
	for _, f := range files {
		fbase := filepath.Base(f)
		c := constPrefix + r.Replace(fbase[:len(fbase)-4]) // trim .spv
		constNames[f] = c
	}

	if err := os.MkdirAll(filepath.Dir(*outFile), os.ModePerm); err != nil {
		fmt.Println("Error creating output file directory:", err)
		os.Exit(1)
	}
	w, err := os.Create(*outFile)
	if err != nil {
		fmt.Println("Error creating output file:", err)
		os.Exit(1)
	}
	defer w.Close()

	// Write header

	w.WriteString(genComment)
	fmt.Fprintf(w, "\n\npackage %s\n\n", *pkg)

	w.WriteString("const (\n")
	for i, f := range files {
		if i == 0 {
			fmt.Fprintf(w, "\t%s = iota\n", constNames[f])
		} else {
			fmt.Fprintf(w, "\t%s\n", constNames[f])
		}
	}
	w.WriteString(")\n\n")

	// Write getter

	var getter string
	if *export {
		getter = "GetSPV"
	} else {
		getter = "getSPV"
	}

	fmt.Fprintf(w, "// %s returns a SPIR-V module for the given index.\n", getter)
	fmt.Fprintf(w, "func %s(which int) []uint32 {\n", getter)
	fmt.Fprintf(w, "\tif which < 0 || which > %d {\n", len(files)-1)
	w.WriteString("\t\tpanic(\"Invalid spvbin index\")\n")
	w.WriteString("\t}\n\n")
	w.WriteString("\tif _spvBin == nil {\n")
	w.WriteString("\t\tpanic(\"spvbin data already cleared\")\n")
	w.WriteString("\t}\n\n")
	w.WriteString("\treturn _spvBin[which]\n")
	w.WriteString("}\n\n")

	// Write binary data

	h := hex.NewEncoder(w)
	e := binary.BigEndian // Literals in Go code are always big-endian

	w.WriteString("var _spvBin = [][]uint32{\n")
	for _, f := range files {
		spv, err := os.Open(f)
		if err != nil {
			fmt.Printf("Error opening file %s: %v", f, err)
			os.Exit(1)
		}

		w.WriteString("\t[]uint32{")
		var b bytes.Buffer
		var fileBO binary.ByteOrder
		var bb [4]byte
		var ui uint32

		spv.Read(bb[:])
		if bb[0] != 0x07 { // assume spirv magic number; 0x07230203
			fileBO = binary.LittleEndian
		} else {
			fileBO = binary.BigEndian
		}
		ui = fileBO.Uint32(bb[:])
		w.WriteString("0x")
		binary.Write(h, e, ui)
		w.WriteString(", ")

		_, err = b.ReadFrom(spv)
		if err != nil {
			fmt.Printf("Error reading file %s:", f)
			fmt.Println(err)
			os.Exit(1)
		}

		for {
			// SPIR-V should always be 4-byte aligned, so we don't worry about
			// how many bytes we read
			_, err := b.Read(bb[:])
			if err != nil {
				break
			}
			w.WriteString("0x")
			ui = fileBO.Uint32(bb[:])
			binary.Write(h, e, ui)

			if b.Len() == 0 {
				break
			} else {
				w.WriteString(", ")
			}
		}

		w.WriteString("},\n")
	}
	w.WriteString("}\n\n")

	// Write clearing function

	if *clearFunc {
		var cls string
		if *export {
			cls = "SPVClear"
		} else {
			cls = "spvClear"
		}

		fmt.Fprintf(w, "// %s clears the embedded SPIR-V modules from memory.\n", cls)
		fmt.Fprintf(w, "func %s() {\n", cls)
		w.WriteString("\t_spvBin = nil\n")
		w.WriteString("}\n\n")
	}
}
